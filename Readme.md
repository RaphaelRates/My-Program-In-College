# My Program in College

> Anota√ß√µes sobre os princ√≠pios da programa√ß√£o feitas com bastante esfor√ßo, suor e muito caf√© ‚òï  
> Tudo escrito e organizado no **Obsidian**, cobrindo toda minha jornada na gradua√ß√£o de **Matem√°tica Computacional (UFCA)** nas mat√©rias de matem√°tica

---

## üìö Sobre o reposit√≥rio

Este reposit√≥rio re√∫ne **minhas notas, resumos e demonstra√ß√µes** produzidas ao longo das disciplinas fundamentais da √°rea da tecnologia que adquiri durante meu tempo na faculdade.  
Os arquivos foram todos escritos em **Markdown**, otimizados tanto para leitura no **Obsidian** quanto no **GitHub**, com blocos visuais (Adminotion) e formata√ß√£o rica para estudo.

O objetivo √© **consolidar teoria + intui√ß√£o + c√≥digo, criando um acervo naveg√°vel e vivo.

---

## üèõÔ∏è Disciplinas cobertas

| √Årea                                         | Disciplinas                                              | Descri√ß√£o breve                                                                     |
| -------------------------------------------- | -------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| üíª **Introdu√ß√£o √† Programa√ß√£o**              | Fundamentos de Programa√ß√£o                               | Conceitos b√°sicos, l√≥gica, estruturas de controle, fun√ß√µes e manipula√ß√£o de dados   |
| üß± **Programa√ß√£o Orientada a Objetos**       | POO I e II                                               | Abstra√ß√£o, encapsulamento, heran√ßa, polimorfismo e padr√µes de projeto               |
| üßÆ **Algoritmos e Estruturas de Dados**      | Algoritmos em Grafos, Estruturas Lineares e N√£o Lineares | Representa√ß√µes, busca, ordena√ß√£o, caminhos m√≠nimos e complexidade computacional     |
| üé® **Computa√ß√£o Gr√°fica**                    | Modelagem e Renderiza√ß√£o Gr√°fica                         | Transforma√ß√µes geom√©tricas, proje√ß√µes, rasteriza√ß√£o e uso de bibliotecas gr√°ficas   |
| üñºÔ∏è **Processamento de Imagens**             | An√°lise e Transforma√ß√µes de Imagens Digitais             | Filtros, detec√ß√£o de bordas, histogramas, segmenta√ß√£o e compress√£o                  |
| üîä **Processamento Digital de Sinais (PDS)** | An√°lise e Manipula√ß√£o de Sinais                          | Amostragem, transformadas, filtros e aplica√ß√µes em √°udio e sistemas din√¢micos       |
| ü§ñ**Intelig√™ncia Artificial**                | Aprendizado de m√°quina e Machine Learning                | Busca, aprendizado supervisionado e n√£o supervisionado, redes neurais e heur√≠sticas |

---

## üß± Estrutura do reposit√≥rio

```

My-Program-in-College/  
‚îú‚îÄ‚îÄ AED/    
‚îú‚îÄ‚îÄ Algoritmos em Grafos/ 
‚îú‚îÄ‚îÄ Computa√ß√£o Gr√°fica/ 
‚îú‚îÄ‚îÄ Intelig√™ncia Artifical/  
‚îú‚îÄ‚îÄ Introdu√ß√£o a Programa√ß√£o/
‚îú‚îÄ‚îÄ Processamento de Imagens/  
‚îú‚îÄ‚îÄ Processmento Digital de SInais/ 
‚îî‚îÄ‚îÄ Programa√ß√£o Orientada a Objetos/  

```
##### ‚ö†Ô∏è Aviso

> A disciplina de **Processamento Digital de Sinais (PDS)** n√£o faz parte da grade obrigat√≥ria do meu curso ‚Äî estudei por conta pr√≥pria, movido pela curiosidade em entender **como o √°udio pode ser manipulado e analisado computacionalmente**.

---
## üìö √çndice de Disciplinas

### 1. [[Introdu√ß√£o √† Programa√ß√£o]]

### 2. [[Programa√ß√£o Orientada a Objetos]]

### 3. [[Estruturas de Dados]]

### 4. [[Teoria dos Grafos e Algoritmos]]

### 5. [[Intelig√™ncia Artificial]]

---

## üîó Introdu√ß√£o √† Programa√ß√£o em C

### **Disciplina:** Algoritmos e Programa√ß√£o I / Introdu√ß√£o √† Programa√ß√£o

**Carga Hor√°ria:** 60-80h | **Semestre:** 1¬∫-2¬∫

### Conte√∫dos Program√°ticos:

#### **M√≥dulo 1: Fundamentos**

- **1.1** Hist√≥ria da linguagem C e compiladores
- **1.2** Ambiente de desenvolvimento (DevC++, Code::Blocks, GCC)
- **1.3** Estrutura b√°sica de um programa C
- **1.4** Processo de compila√ß√£o e linkagem

#### **M√≥dulo 2: Elementos B√°sicos**

- **2.1** Tipos de dados primitivos (`int`, `float`, `double`, `char`)
- **2.2** Declara√ß√£o e inicializa√ß√£o de vari√°veis
- **2.3** Constantes e diretivas de preprocessador (`#define`)
- **2.4** Operadores aritm√©ticos, relacionais e l√≥gicos
- **2.5** Preced√™ncia de operadores

#### **M√≥dulo 3: Entrada e Sa√≠da**

- **3.1** Fun√ß√µes `printf()` e `scanf()`
- **3.2** Especificadores de formato
- **3.3** Caracteres de escape
- **3.4** Valida√ß√£o de entrada

#### **M√≥dulo 4: Estruturas de Controle**

- **4.1** Estruturas condicionais:
    - `if`, `else if`, `else`
    - `switch-case`
    - Operador tern√°rio
- **4.2** Estruturas de repeti√ß√£o:
    - `for`, `while`, `do-while`
    - `break` e `continue`
    - Loops aninhados

#### **M√≥dulo 5: Vetores e Matrizes**

- **5.1** Declara√ß√£o e inicializa√ß√£o de arrays
- **5.2** Acesso aos elementos
- **5.3** Algoritmos de busca e ordena√ß√£o
- **5.4** Matrizes multidimensionais
- **5.5** Strings como arrays de caracteres

#### **M√≥dulo 6: Fun√ß√µes**

- **6.1** Defini√ß√£o e declara√ß√£o de fun√ß√µes
- **6.2** Passagem de par√¢metros por valor
- **6.3** Escopo de vari√°veis (local vs global)
- **6.4** Recurs√£o
- **6.5** Fun√ß√µes da biblioteca padr√£o

#### **M√≥dulo 7: Ponteiros**

- **7.1** Conceito de endere√ßo de mem√≥ria
- **7.2** Declara√ß√£o e inicializa√ß√£o de ponteiros
- **7.3** Operadores `&` e `*`
- **7.4** Passagem por refer√™ncia
- **7.5** Ponteiros e arrays
- **7.6** Aritm√©tica de ponteiros

#### **M√≥dulo 8: Aloca√ß√£o Din√¢mica**

- **8.1** Fun√ß√µes `malloc()`, `calloc()`, `realloc()`
- **8.2** Fun√ß√£o `free()`
- **8.3** Vazamentos de mem√≥ria
- **8.4** Arrays din√¢micos

#### **M√≥dulo 9: Estruturas (Structs)**

- **9.1** Defini√ß√£o de tipos de dados compostos
- **9.2** Acesso aos membros
- **9.3** Arrays de estruturas
- **9.4** Ponteiros para estruturas
- **9.5** Estruturas aninhadas

#### **M√≥dulo 10: Arquivos**

- **10.1** Fun√ß√µes `fopen()`, `fclose()`
- **10.2** Leitura: `fgetc()`, `fgets()`, `fscanf()`
- **10.3** Escrita: `fputc()`, `fputs()`, `fprintf()`
- **10.4** Posicionamento: `fseek()`, `ftell()`

### **Projetos T√≠picos:**

- Calculadora cient√≠fica
- Sistema de cadastro em arquivo
- Jogo da velha
- Algoritmos de ordena√ß√£o
- Sistema de controle de estoque

---

## ‚òï Programa√ß√£o Orientada a Objetos com Java

### **Disciplina:** POO / Programa√ß√£o Orientada a Objetos

**Carga Hor√°ria:** 60-80h | **Semestre:** 3¬∫-4¬∫

### Conte√∫dos Program√°ticos:

#### **M√≥dulo 1: Paradigma OO**

- **1.1** Evolu√ß√£o dos paradigmas de programa√ß√£o
- **1.2** Conceitos fundamentais de OO
- **1.3** Diferen√ßas entre programa√ß√£o estruturada e OO
- **1.4** Ambiente Java (JDK, JRE, JVM)
- **1.5** IDEs: Eclipse, NetBeans, IntelliJ

#### **M√≥dulo 2: Sintaxe Java B√°sica**

- **2.1** Estrutura de classes e m√©todos
- **2.2** Modificadores de acesso (`public`, `private`, `protected`)
- **2.3** Tipos primitivos e refer√™ncias
- **2.4** Operadores e estruturas de controle
- **2.5** Arrays e cole√ß√µes b√°sicas

#### **M√≥dulo 3: Classes e Objetos**

- **3.1** Defini√ß√£o de classes
- **3.2** Atributos e m√©todos
- **3.3** Construtores e sobrecarga
- **3.4** M√©todo `toString()`
- **3.5** Refer√™ncias `this` e `super`
- **3.6** Garbage Collection

#### **M√≥dulo 4: Encapsulamento**

- **4.1** Modificadores de visibilidade
- **4.2** M√©todos getters e setters
- **4.3** Valida√ß√£o de dados
- **4.4** Princ√≠pio da responsabilidade √∫nica
- **4.5** Imutabilidade de objetos

#### **M√≥dulo 5: Heran√ßa**

- **5.1** Conceito de especializa√ß√£o
- **5.2** Palavra-chave `extends`
- **5.3** Sobrescrita de m√©todos (`@Override`)
- **5.4** Classe `Object`
- **5.5** Construtores em hierarquias
- **5.6** M√©todo `equals()` e `hashCode()`

#### **M√≥dulo 6: Polimorfismo**

- **6.1** Polimorfismo de sobrecarga
- **6.2** Polimorfismo de sobrescrita
- **6.3** Liga√ß√£o din√¢mica (late binding)
- **6.4** Casting de objetos
- **6.5** Operador `instanceof`

#### **M√≥dulo 7: Abstra√ß√£o**

- **7.1** Classes abstratas
- **7.2** M√©todos abstratos
- **7.3** Interfaces
- **7.4** Implementa√ß√£o m√∫ltipla
- **7.5** Interfaces funcionais (Java 8+)

#### **M√≥dulo 8: Cole√ß√µes (Collections)**

- **8.1** Interface `Collection`
- **8.2** `List`: `ArrayList`, `LinkedList`
- **8.3** `Set`: `HashSet`, `TreeSet`
- **8.4** `Map`: `HashMap`, `TreeMap`
- **8.5** Iteradores e enhanced for

#### **M√≥dulo 9: Tratamento de Exce√ß√µes**

- **9.1** Tipos de erros
- **9.2** Hierarquia de exce√ß√µes
- **9.3** `try-catch-finally`
- **9.4** Cria√ß√£o de exce√ß√µes customizadas
- **9.5** `throws` e `throw`

#### **M√≥dulo 10: Entrada/Sa√≠da**

- **10.1** Streams de bytes e caracteres
- **10.2** Classes `FileInputStream`, `FileOutputStream`
- **10.3** `BufferedReader`, `BufferedWriter`
- **10.4** Serializa√ß√£o de objetos
- **10.5** Scanner para entrada de dados

#### **M√≥dulo 11: Padr√µes de Projeto**

- **11.1** Singleton
- **11.2** Factory Method
- **11.3** Observer
- **11.4** Strategy
- **11.5** MVC (Model-View-Controller)

#### **M√≥dulo 12: Programa√ß√£o Concorrente (B√°sico)**

- **12.1** Threads em Java
- **12.2** Classe `Thread` e interface `Runnable`
- **12.3** Sincroniza√ß√£o (`synchronized`)
- **12.4** M√©todos `wait()`, `notify()`

### **Projetos T√≠picos:**

- Sistema banc√°rio com heran√ßa
- Loja virtual com padr√µes de projeto
- Editor de texto simples
- Sistema de biblioteca
- Jogo com interface gr√°fica (Swing)

---

## üóÉÔ∏è Estruturas de Dados

### **Disciplina:** Estruturas de Dados / Algoritmos e Estruturas de Dados

**Carga Hor√°ria:** 60-80h | **Semestre:** 3¬∫-4¬∫

### Conte√∫dos Program√°ticos:

#### **M√≥dulo 1: An√°lise de Algoritmos**

- **1.1** Conceitos de efici√™ncia
- **1.2** Nota√ß√£o Big O, Œ©, Œò
- **1.3** An√°lise de tempo e espa√ßo
- **1.4** Melhor, pior e caso m√©dio
- **1.5** An√°lise amortizada

#### **M√≥dulo 2: Estruturas Lineares**

**2.1 Listas Lineares:**

- Listas sequenciais (arrays)
- Opera√ß√µes: inser√ß√£o, remo√ß√£o, busca
- Vantagens e desvantagens
- Implementa√ß√£o em C/Java

**2.2 Listas Ligadas:**

- Listas simplesmente ligadas
- Listas duplamente ligadas
- Listas circulares
- Compara√ß√£o com arrays

**2.3 Pilhas (Stacks):**

- Princ√≠pio LIFO
- Opera√ß√µes: push, pop, peek
- Implementa√ß√£o com arrays e listas
- Aplica√ß√µes: express√µes, recurs√£o

**2.4 Filas (Queues):**

- Princ√≠pio FIFO
- Fila simples e circular
- Deque (Double-ended queue)
- Fila de prioridade

#### **M√≥dulo 3: Recurs√£o**

- **3.1** Conceitos fundamentais
- **3.2** Casos base e recursivos
- **3.3** Torres de Han√≥i
- **3.4** Fibonacci recursivo vs iterativo
- **3.5** An√°lise de complexidade recursiva

#### **M√≥dulo 4: Algoritmos de Ordena√ß√£o**

**4.1 Ordena√ß√£o Quadr√°tica:**

- Bubble Sort
- Selection Sort
- Insertion Sort

**4.2 Ordena√ß√£o Eficiente:**

- Merge Sort
- Quick Sort
- Heap Sort

**4.3 Ordena√ß√£o Linear:**

- Counting Sort
- Radix Sort
- Bucket Sort

**4.4 An√°lise Comparativa:**

- Estabilidade
- In-place vs out-place
- Compara√ß√£o de desempenho

#### **M√≥dulo 5: Algoritmos de Busca**

- **5.1** Busca linear
- **5.2** Busca bin√°ria
- **5.3** Busca interpolada
- **5.4** Hashing e tabelas hash

#### **M√≥dulo 6: √Årvores**

**6.1 Conceitos B√°sicos:**

- Terminologia (n√≥, folha, altura, grau)
- √Årvores bin√°rias
- Representa√ß√µes: vetor e ponteiros

**6.2 Percursos em √Årvores:**

- Pr√©-ordem (pre-order)
- Em-ordem (in-order)
- P√≥s-ordem (post-order)
- Percurso em largura (level-order)

**6.3 √Årvores Bin√°rias de Busca (BST):**

- Propriedades
- Opera√ß√µes: inser√ß√£o, remo√ß√£o, busca
- An√°lise de complexidade
- Balanceamento

**6.4 √Årvores Balanceadas:**

- √Årvores AVL
- Rota√ß√µes simples e duplas
- √Årvores Red-Black (conceitual)

**6.5 √Årvores B e B+:**

- Conceitos para bancos de dados
- Opera√ß√µes b√°sicas
- Aplica√ß√µes

#### **M√≥dulo 7: Heap**

- **7.1** Propriedades de heap
- **7.2** Max-heap e min-heap
- **7.3** Representa√ß√£o em array
- **7.4** Opera√ß√µes: inser√ß√£o, remo√ß√£o
- **7.5** HeapSort
- **7.6** Fila de prioridade com heap

#### **M√≥dulo 8: Tabelas Hash**

- **8.1** Fun√ß√£o hash
- **8.2** Tratamento de colis√µes:
    - Encadeamento (chaining)
    - Endere√ßamento aberto
- **8.3** Fator de carga
- **8.4** Rehashing
- **8.5** Hash perfeito

### **Implementa√ß√µes T√≠picas:**

- TAD (Tipo Abstrato de Dados) completo
- Biblioteca de estruturas em C
- Comparador de algoritmos de ordena√ß√£o
- Sistema de indexa√ß√£o com hash
- Calculadora com pilha

---

## üåê Teoria dos Grafos e Algoritmos

### **Disciplina:** Grafos / Algoritmos em Grafos

**Carga Hor√°ria:** 40-60h | **Semestre:** 5¬∫-6¬∫

### Conte√∫dos Program√°ticos:

#### **M√≥dulo 1: Conceitos Fundamentais**

- **1.1** Defini√ß√£o matem√°tica de grafos
- **1.2** V√©rtices, arestas, grau
- **1.3** Grafos direcionados vs n√£o-direcionados
- **1.4** Grafos ponderados
- **1.5** Subgrafos, cliques, conjuntos independentes

#### **M√≥dulo 2: Representa√ß√µes**

- **2.1** Lista de adjac√™ncia
- **2.2** Matriz de adjac√™ncia
- **2.3** Lista de arestas
- **2.4** Compara√ß√£o de representa√ß√µes
- **2.5** Implementa√ß√£o em diferentes linguagens

#### **M√≥dulo 3: Algoritmos de Busca**

- **3.1** Busca em Profundidade (DFS):
    
    - Implementa√ß√£o recursiva e iterativa
    - √Årvore DFS
    - Classifica√ß√£o de arestas
    - Detec√ß√£o de ciclos
- **3.2** Busca em Largura (BFS):
    
    - Implementa√ß√£o com fila
    - √Årvore BFS
    - Caminho mais curto (n√£o-ponderado)
    - Componentes conexas

#### **M√≥dulo 4: Conectividade**

- **4.1** Componentes conexas
- **4.2** Componentes fortemente conexas
- **4.3** Algoritmo de Kosaraju
- **4.4** Algoritmo de Tarjan
- **4.5** Pontes e articula√ß√µes

#### **M√≥dulo 5: Caminhos M√≠nimos**

- **5.1** Algoritmo de Dijkstra:
    
    - Implementa√ß√£o com heap
    - Grafos com pesos n√£o-negativos
    - Complexidade e otimiza√ß√µes
- **5.2** Algoritmo de Bellman-Ford:
    
    - Detec√ß√£o de ciclos negativos
    - Caminho m√≠nimo com pesos negativos
- **5.3** Algoritmo de Floyd-Warshall:
    
    - Todos os pares de caminhos m√≠nimos
    - Programa√ß√£o din√¢mica
- **5.4** Algoritmo A*:
    
    - Busca heur√≠stica
    - Fun√ß√£o de avalia√ß√£o
    - Aplica√ß√µes em jogos

#### **M√≥dulo 6: √Årvores Geradoras M√≠nimas**

- **6.1** Conceitos e propriedades
    
- **6.2** Algoritmo de Kruskal:
    
    - Union-Find (Disjoint Set)
    - Implementa√ß√£o e an√°lise
- **6.3** Algoritmo de Prim:
    
    - Implementa√ß√£o com heap
    - Compara√ß√£o com Kruskal

#### **M√≥dulo 7: Fluxo M√°ximo**

- **7.1** Redes de fluxo
- **7.2** Algoritmo Ford-Fulkerson
- **7.3** M√©todo de Edmonds-Karp
- **7.4** Teorema do fluxo m√°ximo-corte m√≠nimo
- **7.5** Aplica√ß√µes pr√°ticas

#### **M√≥dulo 8: Emparelhamento**

- **8.1** Emparelhamento m√°ximo
- **8.2** Grafos bipartidos
- **8.3** Algoritmo h√∫ngaro (conceitual)
- **8.4** Aplica√ß√µes: casamento est√°vel

#### **M√≥dulo 9: Ordena√ß√£o Topol√≥gica**

- **9.1** DAG (Directed Acyclic Graph)
- **9.2** Algoritmo de Kahn
- **9.3** DFS para ordena√ß√£o topol√≥gica
- **9.4** Aplica√ß√µes: depend√™ncias, escalonamento

#### **M√≥dulo 10: Colora√ß√£o de Grafos**

- **10.1** N√∫mero crom√°tico
- **10.2** Algoritmos gulosos
- **10.3** Aplica√ß√µes: escalonamento, conflitos
- **10.4** Teorema das quatro cores (conceitual)

#### **M√≥dulo 11: Grafos Planares**

- **11.1** Defini√ß√£o e propriedades
- **11.2** F√≥rmula de Euler
- **11.3** Teorema de Kuratowski
- **11.4** Algoritmos de planaridade

### **Bibliotecas Utilizadas:**

- **NetworkX** (Python) - an√°lise e visualiza√ß√£o
- **JGraphT** (Java) - algoritmos otimizados
- **Boost Graph Library** (C++) - performance
- **igraph** (R/Python) - an√°lise estat√≠stica

### **Aplica√ß√µes Pr√°ticas:**

- Redes sociais (influenciadores, comunidades)
- GPS e mapas (rotas √≥timas)
- Internet (roteamento, topologia)
- Bioinform√°tica (redes de prote√≠nas)
- Log√≠stica (otimiza√ß√£o de rotas)

---

## ü§ñ Intelig√™ncia Artificial

### **Disciplina:** Intelig√™ncia Artificial / IA

**Carga Hor√°ria:** 60-80h | **Semestre:** 6¬∫-8¬∫

### Conte√∫dos Program√°ticos:

#### **M√≥dulo 1: Fundamentos da IA**

- **1.1** Hist√≥ria e evolu√ß√£o da IA
- **1.2** Defini√ß√µes de intelig√™ncia
- **1.3** Teste de Turing
- **1.4** IA Forte vs IA Fraca
- **1.5** Paradigmas: simb√≥lico, conexionista, evolutivo
- **1.6** Agentes inteligentes e ambientes

#### **M√≥dulo 2: Resolu√ß√£o de Problemas e Busca**

- **2.1** Formula√ß√£o de problemas
    
- **2.2** Espa√ßo de estados
    
- **2.3** Algoritmos de busca cega:
    
    - Busca em largura (BFS)
    - Busca em profundidade (DFS)
    - Busca de custo uniforme
- **2.4** Algoritmos de busca informada:
    
    - Busca gulosa (greedy)
    - Algoritmo A*
    - Fun√ß√µes heur√≠sticas
    - IDA* (Iterative Deepening A*)
- **2.5** Busca local:
    
    - Hill climbing
    - Simulated annealing
    - Algoritmos gen√©ticos

#### **M√≥dulo 3: Jogos e Busca Adversarial**

- **3.1** Teoria dos jogos
- **3.2** Algoritmo Minimax
- **3.3** Poda alfa-beta
- **3.4** Jogos de informa√ß√£o imperfeita
- **3.5** Monte Carlo Tree Search (MCTS)

#### **M√≥dulo 4: Representa√ß√£o do Conhecimento**

- **4.1** L√≥gica proposicional:
    
    - Sintaxe e sem√¢ntica
    - Infer√™ncia e satisfabilidade
    - Algoritmo DPLL
- **4.2** L√≥gica de predicados:
    
    - Quantificadores e termos
    - Unifica√ß√£o e resolu√ß√£o
    - Prolog b√°sico
- **4.3** Representa√ß√µes alternativas:
    
    - Frames e scripts
    - Redes sem√¢nticas
    - Ontologias

#### **M√≥dulo 5: Incerteza e Probabilidade**

- **5.1** Teoria da probabilidade aplicada
    
- **5.2** Teorema de Bayes
    
- **5.3** Redes Bayesianas:
    
    - Constru√ß√£o e infer√™ncia
    - Algoritmos de infer√™ncia exata
    - Infer√™ncia aproximada
- **5.4** Modelos de Markov:
    
    - Cadeias de Markov
    - Hidden Markov Models (HMM)
    - Filtro de Kalman (conceitual)

#### **M√≥dulo 6: Aprendizado de M√°quina**

**6.1 Conceitos Fundamentais:**

- Tipos de aprendizado (supervisionado, n√£o-supervisionado, por refor√ßo)
- Overfitting e underfitting
- Valida√ß√£o cruzada
- M√©tricas de avalia√ß√£o

**6.2 Aprendizado Supervisionado:**

- √Årvores de decis√£o (ID3, C4.5)
- Naive Bayes
- k-Nearest Neighbors (k-NN)
- Support Vector Machines (SVM)
- Regress√£o linear e log√≠stica

**6.3 Aprendizado N√£o-supervisionado:**

- k-Means clustering
- Clustering hier√°rquico
- DBSCAN
- Redu√ß√£o de dimensionalidade (PCA)

**6.4 Aprendizado por Refor√ßo:**

- Processos de decis√£o de Markov (MDP)
- Q-Learning
- Policy gradient
- Temporal difference learning

#### **M√≥dulo 7: Redes Neurais**

- **7.1** Neur√¥nio biol√≥gico vs artificial
- **7.2** Perceptron simples
- **7.3** Perceptron multicamadas (MLP)
- **7.4** Algoritmo backpropagation
- **7.5** Fun√ß√µes de ativa√ß√£o
- **7.6** Regulariza√ß√£o e dropout

#### **M√≥dulo 8: Deep Learning (Introdu√ß√£o)**

- **8.1** Redes neurais profundas
    
- **8.2** Redes Convolucionais (CNN):
    
    - Convolu√ß√£o e pooling
    - Arquiteturas cl√°ssicas (LeNet, AlexNet)
- **8.3** Redes Recorrentes (RNN):
    
    - LSTM e GRU
    - Aplica√ß√µes em sequ√™ncias
- **8.4** Frameworks: TensorFlow, PyTorch, Keras
    

#### **M√≥dulo 9: Processamento de Linguagem Natural**

- **9.1** An√°lise l√©xica e sint√°tica
- **9.2** N-gramas e modelos de linguagem
- **9.3** An√°lise de sentimentos
- **9.4** Tradu√ß√£o autom√°tica (conceitos)
- **9.5** Word embeddings (Word2Vec, GloVe)

#### **M√≥dulo 10: Vis√£o Computacional**

- **10.1** Processamento de imagens b√°sico
- **10.2** Detec√ß√£o de bordas e features
- **10.3** Classifica√ß√£o de imagens
- **10.4** Detec√ß√£o de objetos (conceitos)
- **10.5** OpenCV b√°sico

#### **M√≥dulo 11: Sistemas Multiagentes**

- **11.1** Coordena√ß√£o e coopera√ß√£o
- **11.2** Protocolos de comunica√ß√£o
- **11.3** Leil√µes e negocia√ß√£o
- **11.4** Sistemas distribu√≠dos inteligentes

#### **M√≥dulo 12: √âtica e IA**

- **12.1** Vi√©s algor√≠tmico
- **12.2** Transpar√™ncia e explicabilidade
- **12.3** Privacidade e seguran√ßa
- **12.4** Impacto socioecon√¥mico
- **12.5** Regulamenta√ß√£o e governan√ßa

### **Ferramentas e Bibliotecas:**

**Python:**

- scikit-learn (ML tradicional)
- TensorFlow/Keras (Deep Learning)
- PyTorch (Pesquisa e produ√ß√£o)
- NLTK/spaCy (NLP)
- OpenCV (Vis√£o computacional)

**Outras:**

- Weka (interface gr√°fica para ML)
- R (estat√≠stica e ML)
- Prolog (programa√ß√£o l√≥gica)
- CLIPS (sistemas especialistas)

### **Projetos T√≠picos:**

- Sistema especialista para diagn√≥stico
- Classificador de imagens com CNN
- Chatbot com NLP
- Agente para jogar jogo da velha
- An√°lise de sentimentos em redes sociais
- Sistema de recomenda√ß√£o
- Detector de spam
- Agente navegador em labirinto

### **Metodologia de Avalia√ß√£o:**

- Provas te√≥ricas (40-50%)
- Projetos pr√°ticos (30-40%)
- Semin√°rios/apresenta√ß√µes (10-20%)
- Listas de exerc√≠cios (opcional)

---

## üìä Cronograma Sugerido de Estudos

### **Semestre 1-2

- Introdu√ß√£o √† Programa√ß√£o (C)
-  POO (Java)

### **Semestre 3-4
- Estruturas de Dados
- Banco de Dados

### **Semestre 5-6:**

- An√°lise de Algoritmos
- Teoria dos Grafos
- Compiladores
- Computa√ß√£o gr√°fica

### **Semestre 7-8:** 

- Intelig√™ncia Artificial e Machine Learning
- Processamento de Imagens
- Processamento Digital de Sinais

---

## üéØ Dicas 

### **Estrat√©gias de Estudo:**

1. **Pr√°tica constante** - c√≥digo todos os dias
2. **Projetos incrementais** - comece simples, evolua gradualmente
3. **Grupos de estudo** - discuta conceitos com colegas
4. **Documenta√ß√£o** - comente seu c√≥digo, mantenha notas
5. **Debugging sistem√°tico** - use depuradores, prints estrat√©gicos

### **Recursos Complementares:**

- **Livros cl√°ssicos:** Cormen (Algoritmos), Deitel (Java), Tanenbaum (SO)
- **Plataformas:** HackerRank, LeetCode, URI Online Judge
- **MOOCs:** Coursera, edX, Udacity
- **Comunidades:** Stack Overflow, Reddit, Discord servers

### **Prepara√ß√£o para Mercado:**

- **GitHub ativo** - portf√≥lio de projetos
- **LinkedIn t√©cnico** - skills e certifica√ß√µes
- **Hackathons** - experi√™ncia pr√°tica em equipe
- **Est√°gios** - aplica√ß√£o real dos conhecimentos
- **Networking** - eventos, meetups, confer√™ncias

---

_Este guia representa o conte√∫do padr√£o de cursos de Ci√™ncia da Computa√ß√£o/Engenharia de Software. As disciplinas podem variar entre institui√ß√µes, mas os conceitos fundamentais permanecem consistentes._